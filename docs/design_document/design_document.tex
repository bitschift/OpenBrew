\documentclass[draftclsnofoot,onecolumn,letterpaper,10pt]{IEEEtran}
\pagestyle{empty}
\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

\newcommand{\subparagraph}{}
\usepackage{titlesec}

\titleformat{\section}[block]{\bfseries\Large}{\thesection}{0.4em}{}
\titleformat{\subsection}[block]{\bfseries\large}{\thesubsection}{0.4em}{}
\titleformat{\subsubsection}[block]{\bfseries\normalsize}{\thesubsubsection}{0.4em}{}
\setlength{\parindent}{0pt}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}



\date{\today}

\title{brew.ai Design Document}

\begin{document}
{\huge\textbf{Senior Software Engineering Design Group 7}}
	\vspace{1cm}

{\Huge\textbf{brew.ai Design Document}}

\vspace{2cm}
\textbf{Connor Yates} yatesco@oregonstate.edu

\textbf{Aravind Parasurama} parasura@oregonstate.edu

\textbf{Cody Holliday} hollidac@oregonstate.edu

\vspace{2cm}
Sponsor

Dale McCauley, College of Business, Oregon State University

\vspace{0.5cm}
	Approved: \today{}

	Version: 1.0


\newpage
\begin{abstract}
	Home beer or mead brewing is not currently a process as simple as brewing coffee.
	We aim to change this, and make home brewing as easy as brewing coffee with the OpenBrew project.
	The OpenBrew project will consist of two major components:
	A hardware system for physically automating the brewing process, and a software system for managing the brewing process, utilizing machine learning 
		to optimize mead or beer recipes.
	Through these components, a user will be able to easily incorporate a fully automated, intelligent home brewing system into an existing setup or 
		as the framework to construct a new brewing system.
\end{abstract}
\newpage
\tableofcontents
\newpage
\section{Introduction}
% Perhaps get rid of these subsection titles, and just combine it into one larger section with appropriate paragraph spacings.
% These talk about the Purpose, scope, etc, of this paper.
brew.ai is a hardware and software solution for automated brewing of mead or beer. Currently, home brewing requires a lot of time, knowledge, and 
	patience. 
As such, it is not accessible to amateurs, and brew.ai attempts to solve this problem. 
From amateurs to professional brewers, we want brew.ai to be useful in automating the brewing process, and helping brewers make better tasting products. 
The brew.ai device itself is a bucket lid that will fit over a brewing device and have various modules incorporated in it. 
The lid device will monitor and control temperature, send and receive commands/data to and from the Android application, and monitor fermentation status.
Improving recipes will take place in the back-end, in the form of a service that the Android software will communicate with. 
As a user, setup will simple and essentially plug-and-play. 
No technical knowledge is needed beyond knowing how to pair a bluetooth bucket lid with an Android device.

\section{Glossary}

\section{Stakeholders and Design Concerns}
% Here we list out the design concerns of stakeholders (users, etc...) that we address in this document.
% By laying out the design concerns now, we can address each in turn in the subsequent design sections.

\section{Design Viewpoints}
% Details each design point we choose for this project.
% The tech review had 3 technologies, with 3 choices/investigations for each tech.
% Each of the three technologies chosen should be designed in detail in its own "viewpoint".
% each viewpoint then has its own "view". There can be more than one of these.
% the views describe the specific implementations that each viewpoint covers. Refer to the doc for more info.

\subsection{Abstract Learning from Previous Trials} %connor's
\subsubsection{Learning Algorithm} % Replace with design viewpoint name.
% talk about what algorithm I chose.
% Any design considerations that this algorithm requires
% design of this piece, in the context of the project

\subsubsection{Decision Making Structures}

\subsubsection{Library Implementations}

\subsubsection{Overall Learning Structure}
% diagram showing the interaction between the three previous viewpoints

\subsection{Android-Based User Interface Design} %cody's
\subsubsection{Interface Device}
The device chosen for the user interface was the Android device.
Android has a well-used set of tools and a huge community for development, which is why it is the best choice.
IDEs like Android Studio are continuously developed to support third party development \cite{AndroidStudio}.
In addition, Android devices can be found at a reasonable price.
The average Android device in 2014 was around \$250\cite{AndroidStats}, but the Blu Stduio X8 HD is available for \$49.99 as of November 30, 2016 \cite{BluStudioX8}.
The screen is 5 inches from corner to corner, which provides enough space to have many options or buttons on screen.
Our choices are not limited to one device, since there are many other phone manufacturers that produce Android devices.

Choosing the Android as the user interface device determines how the interface is implemented.
Android uses XML for the design and Java for functionality.
Other options are available for programming an Android App, but they are mostly for developing videogames \cite{Pygame}.
Our goals only involve a simple button interface as well as graphical display of data.
Android also offers special libraries that enable native graphing on the device. 
The choice of interface device also affects how the Controller interacts with the interface.
Rather than just being a display for the controller, the Android will have to implement protocol to interact with the controller so that there is a logical flow of data and control.
The data flow between the Android and the controller will be implemented using a TCP connection rather than designing our own message protocol.

\subsubsection{UI Connection to controller}
A USB connection to the controller was determined as the best option for this project.
A simple method of interfacing the Android to the controller is using an Android Debug Bridge \cite{ADBDOCS}.
The Android Debug Bridge is a program that  allows an Android device to be controlled via the command line.
The command line tool allows a PC to manage app installation and activity, as well as file transfers to the device from the PC.
ADB can be installed on a Raspberry Pi, so there are no inherent issues with compatibility \cite{ADBPI}.
To transfer data from the controller to the Android, the controller can just use the ADB command line tool to send the data as a file to the device.
The ADB also allows for port forwarding, so the Android device will communicate with the controller via a TCP connection.
The simplicity of this interface allows for more complex control mechanisms between the controller and the interface as well as leaves room for design improvements.

The controller will have a Python program running that will interact with the Android device using a combination of sockets and bash scripts.
The sockets will be used for control mechanisms, such as starting the brewing process, and the bash scripts will be used as a method for sending data.
Data from a batch is sent from the controller to the Android as a file so that the Android can graph the data locally.
The commands to send the data will live in bash scripts that will be called by the Python program.
Any images that need to be generated on the controller can be sent to the Android via ADB as well.
Physical advantages of a USB connection include preventing loss of data due to interference or connection issues as well as reduce the number of connections on the power supply.


\subsubsection{Dataflow to UI}
The path the data will take is through the controller to the user interface for analysis.
The interface will receive a copy of the data after it is sent to the controller from the microcontroller.
The controller will format the data into a JSON file using the built in JSON Python library \cite{JSONPython}.
The controller will send a JSON file of the data view the ADB command line interface.
After the user interface receives the data, it will turn the JSON file into an object that it will then use to graph the data.
The analysis will take place in the Android app and take place in an asynchronous thread, to prevent the main thread from locking up the interface.
The thread will use a library called Graphview to graph the data on the device. \cite{Graphview}

Graphing on the Android device will reduce the amount of processing that takes place on the controller.
The processing on the controller should be limited to reinforcement learning and data transfer.
However, data transfer and analysis will not take place at the same time on the controller, so there is not a problem with resource sharing, but there is a worry of long term wear and tear.
The brewing device is a long term solution to the homebrewing problem, so we need to maximize the life of the device.
To prevent premature loss of a CPU, the processing load will be spread out over both the controller and the user interface device.

\subsection{Brewing Hardware and Electronic Controls} %aravind's section
The brewing hardware is expected to perform the commands received from the Android client, while also automatically managing
some basic regulation functions on its own. The hardware will collect data about the brewing process and relay that back to the
Android application.

\subsubsection{Temperature control implementations}
For temperature control, a peltier junction will be used, attached to a heatsink on one side. The temperature control module will
hang from the lid of the device, and touch the liquid so as to apply a temperature differential to the liquid itself. Peltier junctions 
operate with pulse-width modulation, and at the levels of current required, an H-BRIDGE will have to be utilized in conjunction with the 
peltier module.

\subsubsection{Data collection from brewing process}
For data collection, an array of sensors has been chosen:
\begin{enumerate}
	\item A thermocouple, for minimal calibration temperature data gathering
	\item A carbon dioxide sensor, for measuring current fermentation levels
	\item A digital hydrometer for measuring initial gravity
\end{enumerate}
\subsubsection{Hardware connection to the client}
Data will be transmitted to the front-end by means of bluetooth. A bluetooth module will be used that supports interfacing directly with AVR's
USART functionality. This bluetooth module should easily pair with the Android application and transfer data.

\subsubsection{Central control system}
To bring all of the hardware components together, we will be using the Teensy 2.0, powered by the ATmega32u4. This microcontroller allows for basic
routines to be performed, and has a variety of hardware functionality that will be extensively used in this project.

\section{Design Rationale}

\section{Summary}

% References
\bibliography{design_document}
\bibliographystyle{ieeetr}


\end{document}
